<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <title>爱心跳动,3D拖拽搬</title>
  <link rel="stylesheet" href="./css/style.css">

</head>

<body>

    <canvas id="universe"></canvas>

    <script src="./js/universe.js"></script>
  <script src='./js/three.min.js'></script>
  <!-- <script src='./js/MeshSurfaceSampler.js'></script> -->
  <script src='./js/TrackballControls.js'></script>
  <script src='./js/simplex-noise.js'></script>
  <script src='./js/OBJLoader.js'></script>
  <script src='./js/gsap.min.js'></script>
  <script src="./js/script.js"></script>


  <script>


    (function () {
      const _face = new THREE.Triangle();

      const _color = new THREE.Vector3();

      class MeshSurfaceSampler {

        constructor(mesh) {

          let geometry = mesh.geometry;

          if (!geometry.isBufferGeometry || geometry.attributes.position.itemSize !== 3) {

            throw new Error('THREE.MeshSurfaceSampler: Requires BufferGeometry triangle mesh.');

          }

          if (geometry.index) {

            console.warn('THREE.MeshSurfaceSampler: Converting geometry to non-indexed BufferGeometry.');
            geometry = geometry.toNonIndexed();

          }

          this.geometry = geometry;
          this.randomFunction = Math.random;
          this.positionAttribute = this.geometry.getAttribute('position');
          this.colorAttribute = this.geometry.getAttribute('color');
          this.weightAttribute = null;
          this.distribution = null;

        }

        setWeightAttribute(name) {

          this.weightAttribute = name ? this.geometry.getAttribute(name) : null;
          return this;

        }

        build() {

          const positionAttribute = this.positionAttribute;
          const weightAttribute = this.weightAttribute;
          const faceWeights = new Float32Array(positionAttribute.count / 3); // Accumulate weights for each mesh face.

          for (let i = 0; i < positionAttribute.count; i += 3) {

            let faceWeight = 1;

            if (weightAttribute) {

              faceWeight = weightAttribute.getX(i) + weightAttribute.getX(i + 1) + weightAttribute.getX(i + 2);

            }

            _face.a.fromBufferAttribute(positionAttribute, i);

            _face.b.fromBufferAttribute(positionAttribute, i + 1);

            _face.c.fromBufferAttribute(positionAttribute, i + 2);

            faceWeight *= _face.getArea();
            faceWeights[i / 3] = faceWeight;

          } // Store cumulative total face weights in an array, where weight index
          // corresponds to face index.


          this.distribution = new Float32Array(positionAttribute.count / 3);
          let cumulativeTotal = 0;

          for (let i = 0; i < faceWeights.length; i++) {

            cumulativeTotal += faceWeights[i];
            this.distribution[i] = cumulativeTotal;

          }

          return this;

        }

        setRandomGenerator(randomFunction) {

          this.randomFunction = randomFunction;
          return this;

        }

        sample(targetPosition, targetNormal, targetColor) {

          const cumulativeTotal = this.distribution[this.distribution.length - 1];
          const faceIndex = this.binarySearch(this.randomFunction() * cumulativeTotal);
          return this.sampleFace(faceIndex, targetPosition, targetNormal, targetColor);

        }

        binarySearch(x) {

          const dist = this.distribution;
          let start = 0;
          let end = dist.length - 1;
          let index = - 1;

          while (start <= end) {

            const mid = Math.ceil((start + end) / 2);

            if (mid === 0 || dist[mid - 1] <= x && dist[mid] > x) {

              index = mid;
              break;

            } else if (x < dist[mid]) {

              end = mid - 1;

            } else {

              start = mid + 1;

            }

          }

          return index;

        }

        sampleFace(faceIndex, targetPosition, targetNormal, targetColor) {

          let u = this.randomFunction();
          let v = this.randomFunction();

          if (u + v > 1) {

            u = 1 - u;
            v = 1 - v;

          }

          _face.a.fromBufferAttribute(this.positionAttribute, faceIndex * 3);

          _face.b.fromBufferAttribute(this.positionAttribute, faceIndex * 3 + 1);

          _face.c.fromBufferAttribute(this.positionAttribute, faceIndex * 3 + 2);

          targetPosition.set(0, 0, 0).addScaledVector(_face.a, u).addScaledVector(_face.b, v).addScaledVector(_face.c, 1 - (u + v));

          if (targetNormal !== undefined) {

            _face.getNormal(targetNormal);

          }

          if (targetColor !== undefined && this.colorAttribute !== undefined) {

            _face.a.fromBufferAttribute(this.colorAttribute, faceIndex * 3);

            _face.b.fromBufferAttribute(this.colorAttribute, faceIndex * 3 + 1);

            _face.c.fromBufferAttribute(this.colorAttribute, faceIndex * 3 + 2);

            _color.set(0, 0, 0).addScaledVector(_face.a, u).addScaledVector(_face.b, v).addScaledVector(_face.c, 1 - (u + v));

            targetColor.r = _color.x;
            targetColor.g = _color.y;
            targetColor.b = _color.z;
          }
          return this;

        }

      }

      THREE.MeshSurfaceSampler = MeshSurfaceSampler;

    })();

  </script>
  <script>
    (function () {

      const _object_pattern = /^[og]\s*(.+)?/; // mtllib file_reference

      const _material_library_pattern = /^mtllib /; // usemtl material_name

      const _material_use_pattern = /^usemtl /; // usemap map_name

      const _map_use_pattern = /^usemap /;

      const _vA = new THREE.Vector3();

      const _vB = new THREE.Vector3();

      const _vC = new THREE.Vector3();

      const _ab = new THREE.Vector3();

      const _cb = new THREE.Vector3();

      function ParserState() {

        const state = {
          objects: [],
          object: {},
          vertices: [],
          normals: [],
          colors: [],
          uvs: [],
          materials: {},
          materialLibraries: [],
          startObject: function (name, fromDeclaration) {

            // If the current object (initial from reset) is not from a g/o declaration in the parsed
            // file. We need to use it for the first parsed g/o to keep things in sync.
            if (this.object && this.object.fromDeclaration === false) {

              this.object.name = name;
              this.object.fromDeclaration = fromDeclaration !== false;
              return;

            }

            const previousMaterial = this.object && typeof this.object.currentMaterial === 'function' ? this.object.currentMaterial() : undefined;

            if (this.object && typeof this.object._finalize === 'function') {

              this.object._finalize(true);

            }

            this.object = {
              name: name || '',
              fromDeclaration: fromDeclaration !== false,
              geometry: {
                vertices: [],
                normals: [],
                colors: [],
                uvs: [],
                hasUVIndices: false
              },
              materials: [],
              smooth: true,
              startMaterial: function (name, libraries) {

                const previous = this._finalize(false); // New usemtl declaration overwrites an inherited material, except if faces were declared
                // after the material, then it must be preserved for proper MultiMaterial continuation.


                if (previous && (previous.inherited || previous.groupCount <= 0)) {

                  this.materials.splice(previous.index, 1);

                }

                const material = {
                  index: this.materials.length,
                  name: name || '',
                  mtllib: Array.isArray(libraries) && libraries.length > 0 ? libraries[libraries.length - 1] : '',
                  smooth: previous !== undefined ? previous.smooth : this.smooth,
                  groupStart: previous !== undefined ? previous.groupEnd : 0,
                  groupEnd: - 1,
                  groupCount: - 1,
                  inherited: false,
                  clone: function (index) {

                    const cloned = {
                      index: typeof index === 'number' ? index : this.index,
                      name: this.name,
                      mtllib: this.mtllib,
                      smooth: this.smooth,
                      groupStart: 0,
                      groupEnd: - 1,
                      groupCount: - 1,
                      inherited: false
                    };
                    cloned.clone = this.clone.bind(cloned);
                    return cloned;

                  }
                };
                this.materials.push(material);
                return material;

              },
              currentMaterial: function () {

                if (this.materials.length > 0) {

                  return this.materials[this.materials.length - 1];

                }

                return undefined;

              },
              _finalize: function (end) {

                const lastMultiMaterial = this.currentMaterial();

                if (lastMultiMaterial && lastMultiMaterial.groupEnd === - 1) {

                  lastMultiMaterial.groupEnd = this.geometry.vertices.length / 3;
                  lastMultiMaterial.groupCount = lastMultiMaterial.groupEnd - lastMultiMaterial.groupStart;
                  lastMultiMaterial.inherited = false;

                } // Ignore objects tail materials if no face declarations followed them before a new o/g started.


                if (end && this.materials.length > 1) {

                  for (let mi = this.materials.length - 1; mi >= 0; mi--) {

                    if (this.materials[mi].groupCount <= 0) {

                      this.materials.splice(mi, 1);

                    }

                  }

                } // Guarantee at least one empty material, this makes the creation later more straight forward.


                if (end && this.materials.length === 0) {

                  this.materials.push({
                    name: '',
                    smooth: this.smooth
                  });

                }

                return lastMultiMaterial;

              }
            }; // Inherit previous objects material.
            // Spec tells us that a declared material must be set to all objects until a new material is declared.
            // If a usemtl declaration is encountered while this new object is being parsed, it will
            // overwrite the inherited material. Exception being that there was already face declarations
            // to the inherited material, then it will be preserved for proper MultiMaterial continuation.

            if (previousMaterial && previousMaterial.name && typeof previousMaterial.clone === 'function') {

              const declared = previousMaterial.clone(0);
              declared.inherited = true;
              this.object.materials.push(declared);

            }

            this.objects.push(this.object);

          },
          finalize: function () {

            if (this.object && typeof this.object._finalize === 'function') {

              this.object._finalize(true);

            }

          },
          parseVertexIndex: function (value, len) {

            const index = parseInt(value, 10);
            return (index >= 0 ? index - 1 : index + len / 3) * 3;

          },
          parseNormalIndex: function (value, len) {

            const index = parseInt(value, 10);
            return (index >= 0 ? index - 1 : index + len / 3) * 3;

          },
          parseUVIndex: function (value, len) {

            const index = parseInt(value, 10);
            return (index >= 0 ? index - 1 : index + len / 2) * 2;

          },
          addVertex: function (a, b, c) {

            const src = this.vertices;
            const dst = this.object.geometry.vertices;
            dst.push(src[a + 0], src[a + 1], src[a + 2]);
            dst.push(src[b + 0], src[b + 1], src[b + 2]);
            dst.push(src[c + 0], src[c + 1], src[c + 2]);

          },
          addVertexPoint: function (a) {

            const src = this.vertices;
            const dst = this.object.geometry.vertices;
            dst.push(src[a + 0], src[a + 1], src[a + 2]);

          },
          addVertexLine: function (a) {

            const src = this.vertices;
            const dst = this.object.geometry.vertices;
            dst.push(src[a + 0], src[a + 1], src[a + 2]);

          },
          addNormal: function (a, b, c) {

            const src = this.normals;
            const dst = this.object.geometry.normals;
            dst.push(src[a + 0], src[a + 1], src[a + 2]);
            dst.push(src[b + 0], src[b + 1], src[b + 2]);
            dst.push(src[c + 0], src[c + 1], src[c + 2]);

          },
          addFaceNormal: function (a, b, c) {

            const src = this.vertices;
            const dst = this.object.geometry.normals;

            _vA.fromArray(src, a);

            _vB.fromArray(src, b);

            _vC.fromArray(src, c);

            _cb.subVectors(_vC, _vB);

            _ab.subVectors(_vA, _vB);

            _cb.cross(_ab);

            _cb.normalize();

            dst.push(_cb.x, _cb.y, _cb.z);
            dst.push(_cb.x, _cb.y, _cb.z);
            dst.push(_cb.x, _cb.y, _cb.z);

          },
          addColor: function (a, b, c) {

            const src = this.colors;
            const dst = this.object.geometry.colors;
            if (src[a] !== undefined) dst.push(src[a + 0], src[a + 1], src[a + 2]);
            if (src[b] !== undefined) dst.push(src[b + 0], src[b + 1], src[b + 2]);
            if (src[c] !== undefined) dst.push(src[c + 0], src[c + 1], src[c + 2]);

          },
          addUV: function (a, b, c) {

            const src = this.uvs;
            const dst = this.object.geometry.uvs;
            dst.push(src[a + 0], src[a + 1]);
            dst.push(src[b + 0], src[b + 1]);
            dst.push(src[c + 0], src[c + 1]);

          },
          addDefaultUV: function () {

            const dst = this.object.geometry.uvs;
            dst.push(0, 0);
            dst.push(0, 0);
            dst.push(0, 0);

          },
          addUVLine: function (a) {

            const src = this.uvs;
            const dst = this.object.geometry.uvs;
            dst.push(src[a + 0], src[a + 1]);

          },
          addFace: function (a, b, c, ua, ub, uc, na, nb, nc) {

            const vLen = this.vertices.length;
            let ia = this.parseVertexIndex(a, vLen);
            let ib = this.parseVertexIndex(b, vLen);
            let ic = this.parseVertexIndex(c, vLen);
            this.addVertex(ia, ib, ic);
            this.addColor(ia, ib, ic); // normals

            if (na !== undefined && na !== '') {

              const nLen = this.normals.length;
              ia = this.parseNormalIndex(na, nLen);
              ib = this.parseNormalIndex(nb, nLen);
              ic = this.parseNormalIndex(nc, nLen);
              this.addNormal(ia, ib, ic);

            } else {

              this.addFaceNormal(ia, ib, ic);

            } // uvs


            if (ua !== undefined && ua !== '') {

              const uvLen = this.uvs.length;
              ia = this.parseUVIndex(ua, uvLen);
              ib = this.parseUVIndex(ub, uvLen);
              ic = this.parseUVIndex(uc, uvLen);
              this.addUV(ia, ib, ic);
              this.object.geometry.hasUVIndices = true;

            } else {

              // add placeholder values (for inconsistent face definitions)
              this.addDefaultUV();

            }

          },
          addPointGeometry: function (vertices) {

            this.object.geometry.type = 'Points';
            const vLen = this.vertices.length;

            for (let vi = 0, l = vertices.length; vi < l; vi++) {

              const index = this.parseVertexIndex(vertices[vi], vLen);
              this.addVertexPoint(index);
              this.addColor(index);

            }

          },
          addLineGeometry: function (vertices, uvs) {

            this.object.geometry.type = 'Line';
            const vLen = this.vertices.length;
            const uvLen = this.uvs.length;

            for (let vi = 0, l = vertices.length; vi < l; vi++) {

              this.addVertexLine(this.parseVertexIndex(vertices[vi], vLen));

            }

            for (let uvi = 0, l = uvs.length; uvi < l; uvi++) {

              this.addUVLine(this.parseUVIndex(uvs[uvi], uvLen));

            }

          }
        };
        state.startObject('', false);
        return state;

      } //


      class OBJLoader extends THREE.Loader {

        constructor(manager) {

          super(manager);
          this.materials = null;

        }

        load(url, onLoad, onProgress, onError) {

          const scope = this;
          const loader = new THREE.FileLoader(this.manager);
          loader.setPath(this.path);
          loader.setRequestHeader(this.requestHeader);
          loader.setWithCredentials(this.withCredentials);
          loader.load(url, function (text) {

            try {

              onLoad(scope.parse(text));

            } catch (e) {

              if (onError) {

                onError(e);

              } else {

                console.error(e);

              }

              scope.manager.itemError(url);

            }

          }, onProgress, onError);

        }

        setMaterials(materials) {

          this.materials = materials;
          return this;

        }

        parse(text) {

          const state = new ParserState();

          if (text.indexOf('\r\n') !== - 1) {

            // This is faster than String.split with regex that splits on both
            text = text.replace(/\r\n/g, '\n');

          }

          if (text.indexOf('\\\n') !== - 1) {

            // join lines separated by a line continuation character (\)
            text = text.replace(/\\\n/g, '');

          }

          const lines = text.split('\n');
          let line = '',
            lineFirstChar = '';
          let lineLength = 0;
          let result = []; // Faster to just trim left side of the line. Use if available.

          const trimLeft = typeof ''.trimLeft === 'function';

          for (let i = 0, l = lines.length; i < l; i++) {

            line = lines[i];
            line = trimLeft ? line.trimLeft() : line.trim();
            lineLength = line.length;
            if (lineLength === 0) continue;
            lineFirstChar = line.charAt(0); // @todo invoke passed in handler if any

            if (lineFirstChar === '#') continue;

            if (lineFirstChar === 'v') {

              const data = line.split(/\s+/);

              switch (data[0]) {

                case 'v':
                  state.vertices.push(parseFloat(data[1]), parseFloat(data[2]), parseFloat(data[3]));

                  if (data.length >= 7) {

                    state.colors.push(parseFloat(data[4]), parseFloat(data[5]), parseFloat(data[6]));

                  } else {

                    // if no colors are defined, add placeholders so color and vertex indices match
                    state.colors.push(undefined, undefined, undefined);

                  }

                  break;

                case 'vn':
                  state.normals.push(parseFloat(data[1]), parseFloat(data[2]), parseFloat(data[3]));
                  break;

                case 'vt':
                  state.uvs.push(parseFloat(data[1]), parseFloat(data[2]));
                  break;

              }

            } else if (lineFirstChar === 'f') {

              const lineData = line.substr(1).trim();
              const vertexData = lineData.split(/\s+/);
              const faceVertices = []; // Parse the face vertex data into an easy to work with format

              for (let j = 0, jl = vertexData.length; j < jl; j++) {

                const vertex = vertexData[j];

                if (vertex.length > 0) {

                  const vertexParts = vertex.split('/');
                  faceVertices.push(vertexParts);

                }

              } // Draw an edge between the first vertex and all subsequent vertices to form an n-gon


              const v1 = faceVertices[0];

              for (let j = 1, jl = faceVertices.length - 1; j < jl; j++) {

                const v2 = faceVertices[j];
                const v3 = faceVertices[j + 1];
                state.addFace(v1[0], v2[0], v3[0], v1[1], v2[1], v3[1], v1[2], v2[2], v3[2]);

              }

            } else if (lineFirstChar === 'l') {

              const lineParts = line.substring(1).trim().split(' ');
              let lineVertices = [];
              const lineUVs = [];

              if (line.indexOf('/') === - 1) {

                lineVertices = lineParts;

              } else {

                for (let li = 0, llen = lineParts.length; li < llen; li++) {

                  const parts = lineParts[li].split('/');
                  if (parts[0] !== '') lineVertices.push(parts[0]);
                  if (parts[1] !== '') lineUVs.push(parts[1]);

                }

              }

              state.addLineGeometry(lineVertices, lineUVs);

            } else if (lineFirstChar === 'p') {

              const lineData = line.substr(1).trim();
              const pointData = lineData.split(' ');
              state.addPointGeometry(pointData);

            } else if ((result = _object_pattern.exec(line)) !== null) {

              // o object_name
              // or
              // g group_name
              // WORKAROUND: https://bugs.chromium.org/p/v8/issues/detail?id=2869
              // let name = result[ 0 ].substr( 1 ).trim();
              const name = (' ' + result[0].substr(1).trim()).substr(1);
              state.startObject(name);

            } else if (_material_use_pattern.test(line)) {

              // material
              state.object.startMaterial(line.substring(7).trim(), state.materialLibraries);

            } else if (_material_library_pattern.test(line)) {

              // mtl file
              state.materialLibraries.push(line.substring(7).trim());

            } else if (_map_use_pattern.test(line)) {

              // the line is parsed but ignored since the loader assumes textures are defined MTL files
              // (according to https://www.okino.com/conv/imp_wave.htm, 'usemap' is the old-style Wavefront texture reference method)
              console.warn('THREE.OBJLoader: Rendering identifier "usemap" not supported. Textures must be defined in MTL files.');

            } else if (lineFirstChar === 's') {

              result = line.split(' '); // smooth shading
              // @todo Handle files that have varying smooth values for a set of faces inside one geometry,
              // but does not define a usemtl for each face set.
              // this should be detected and a dummy material created (later MultiMaterial and geometry groups).
              // this requires some care to not create extra material on each smooth value for "normal" obj files.
              // where explicit usemtl defines geometry groups.
              // Example asset: examples/models/obj/cerberus/Cerberus.obj

              /*
               * http://paulbourke.net/dataformats/obj/
               * or
               * http://www.cs.utah.edu/~boulos/cs3505/obj_spec.pdf
               *
               * From chapter "Grouping" Syntax explanation "s group_number":
               * "group_number is the smoothing group number. To turn off smoothing groups, use a value of 0 or off.
               * Polygonal elements use group numbers to put elements in different smoothing groups. For free-form
               * surfaces, smoothing groups are either turned on or off; there is no difference between values greater
               * than 0."
               */

              if (result.length > 1) {

                const value = result[1].trim().toLowerCase();
                state.object.smooth = value !== '0' && value !== 'off';

              } else {

                // ZBrush can produce "s" lines #11707
                state.object.smooth = true;

              }

              const material = state.object.currentMaterial();
              if (material) material.smooth = state.object.smooth;

            } else {

              // Handle null terminated files without exception
              if (line === '\0') continue;
              console.warn('THREE.OBJLoader: Unexpected line: "' + line + '"');

            }

          }

          state.finalize();
          const container = new THREE.Group();
          container.materialLibraries = [].concat(state.materialLibraries);
          const hasPrimitives = !(state.objects.length === 1 && state.objects[0].geometry.vertices.length === 0);

          if (hasPrimitives === true) {

            for (let i = 0, l = state.objects.length; i < l; i++) {

              const object = state.objects[i];
              const geometry = object.geometry;
              const materials = object.materials;
              const isLine = geometry.type === 'Line';
              const isPoints = geometry.type === 'Points';
              let hasVertexColors = false; // Skip o/g line declarations that did not follow with any faces

              if (geometry.vertices.length === 0) continue;
              const buffergeometry = new THREE.BufferGeometry();
              buffergeometry.setAttribute('position', new THREE.Float32BufferAttribute(geometry.vertices, 3));

              if (geometry.normals.length > 0) {

                buffergeometry.setAttribute('normal', new THREE.Float32BufferAttribute(geometry.normals, 3));

              }

              if (geometry.colors.length > 0) {

                hasVertexColors = true;
                buffergeometry.setAttribute('color', new THREE.Float32BufferAttribute(geometry.colors, 3));

              }

              if (geometry.hasUVIndices === true) {

                buffergeometry.setAttribute('uv', new THREE.Float32BufferAttribute(geometry.uvs, 2));

              } // Create materials


              const createdMaterials = [];

              for (let mi = 0, miLen = materials.length; mi < miLen; mi++) {

                const sourceMaterial = materials[mi];
                const materialHash = sourceMaterial.name + '_' + sourceMaterial.smooth + '_' + hasVertexColors;
                let material = state.materials[materialHash];

                if (this.materials !== null) {

                  material = this.materials.create(sourceMaterial.name); // mtl etc. loaders probably can't create line materials correctly, copy properties to a line material.

                  if (isLine && material && !(material instanceof THREE.LineBasicMaterial)) {

                    const materialLine = new THREE.LineBasicMaterial();
                    THREE.Material.prototype.copy.call(materialLine, material);
                    materialLine.color.copy(material.color);
                    material = materialLine;

                  } else if (isPoints && material && !(material instanceof THREE.PointsMaterial)) {

                    const materialPoints = new THREE.PointsMaterial({
                      size: 10,
                      sizeAttenuation: false
                    });
                    THREE.Material.prototype.copy.call(materialPoints, material);
                    materialPoints.color.copy(material.color);
                    materialPoints.map = material.map;
                    material = materialPoints;

                  }

                }

                if (material === undefined) {

                  if (isLine) {

                    material = new THREE.LineBasicMaterial();

                  } else if (isPoints) {

                    material = new THREE.PointsMaterial({
                      size: 1,
                      sizeAttenuation: false
                    });

                  } else {

                    material = new THREE.MeshPhongMaterial();

                  }

                  material.name = sourceMaterial.name;
                  material.flatShading = sourceMaterial.smooth ? false : true;
                  material.vertexColors = hasVertexColors;
                  state.materials[materialHash] = material;

                }

                createdMaterials.push(material);

              } // Create mesh


              let mesh;

              if (createdMaterials.length > 1) {

                for (let mi = 0, miLen = materials.length; mi < miLen; mi++) {

                  const sourceMaterial = materials[mi];
                  buffergeometry.addGroup(sourceMaterial.groupStart, sourceMaterial.groupCount, mi);

                }

                if (isLine) {

                  mesh = new THREE.LineSegments(buffergeometry, createdMaterials);

                } else if (isPoints) {

                  mesh = new THREE.Points(buffergeometry, createdMaterials);

                } else {

                  mesh = new THREE.Mesh(buffergeometry, createdMaterials);

                }

              } else {

                if (isLine) {

                  mesh = new THREE.LineSegments(buffergeometry, createdMaterials[0]);

                } else if (isPoints) {

                  mesh = new THREE.Points(buffergeometry, createdMaterials[0]);

                } else {

                  mesh = new THREE.Mesh(buffergeometry, createdMaterials[0]);

                }

              }

              mesh.name = object.name;
              container.add(mesh);

            }

          } else {

            // if there is only the default parser state object with no geometry data, interpret data as point cloud
            if (state.vertices.length > 0) {

              const material = new THREE.PointsMaterial({
                size: 1,
                sizeAttenuation: false
              });
              const buffergeometry = new THREE.BufferGeometry();
              buffergeometry.setAttribute('position', new THREE.Float32BufferAttribute(state.vertices, 3));

              if (state.colors.length > 0 && state.colors[0] !== undefined) {

                buffergeometry.setAttribute('color', new THREE.Float32BufferAttribute(state.colors, 3));
                material.vertexColors = true;

              }

              const points = new THREE.Points(buffergeometry, material);
              container.add(points);

            }

          }

          return container;

        }

      }

      THREE.OBJLoader = OBJLoader;

    })();

  </script>
  
  <div class="container">
    <div class="content">
      <canvas id="universe"></canvas>
      <canvas id="canvas"></canvas>
      <!-- <iframe src="audio/[No Copyright Music] Unconditionally - Broken Elegance.mp3" allow="autoplay" -->
      <iframe src="audio/[No Copyright Music] Unconditionally - Broken Elegance.mp3" 
        style="display:none" id="iframeAudio"></iframe>
      <!-- <audio autoplay loop> -->
        <audio  loop>
        <source src="audio/[No Copyright Music] Unconditionally - Broken Elegance.mp3" type="audio/mpeg">
      </audio>
      <div id="footer" class="">
        <svg id="scene" x="0%" y="0%" width="300%" height="100%">
          <path id="ground" d="M0,316.4209c0,0,157.7119-35.416,469-56c7.3833-0.4883,23.7876-3.5488,31.3335-4.0166
            c3.7681-0.2334,19.4302,0.9424,28.3335,0.3506c17.1494-1.1396,30.9072-4.2734,38.333-4.6836
            c7.5972-0.4189,18.4058,0.3799,27.6665-0.9834c5.7075-0.8408,10.1318-4.042,14.9248-4.2705
            c7.8369-0.373,24.5693,3.6084,34.4087,4.2705c11.0586,0.7432,15.2656-1.8135,24.3335-2.1523c10.0576-0.376,20.4629,1.3867,28.6665,0
            c3.5957-0.6074,4.4194,0.4209,7.7227-0.7715c1.4927-0.5391,5.8179-3.5693,6.9438-4.2432c3.8335,0.667,6.1426-1.0732,9.917-1.167
            c2.2739-0.0566,3.9673-0.9072,6.249-0.9609c2.2725-0.0537,5.5547-1.2383,7.8345-1.2881c2.25-0.0498,3.498,1.0352,5.7554,0.9883
            c2.9648-0.0615,7.9341,0.3164,10.9111,0.2607c2.2461-0.042,2.4976-0.5195,4.7505-0.5586c2.9663-0.0518,2.1045-0.5615,5.0825-0.6074
            c1.5811-0.0244,6.9976,0.4131,8.582,0.3896c0.8887-0.0127,2.6113,0.373,3.5015,0.3604c1.5527-0.0215,2.2739-0.4404,3.8296-0.4609
            c1.416-0.0186,2.0854-0.8555,3.5039-0.873c1.0835-0.0127,2.9155,0.7939,4.0005,0.7813c1.1104-0.0127,3.5542,0.4805,4.666,0.4688
            c1.3047-0.0137,1.2773-0.5332,2.584-0.5459c1.415-0.0137,1.165-0.4414,2.5825-0.4541c0.916-0.0078,3.499,0.3984,4.416,0.3906
            c1.499-0.0127,1.833,0.6221,3.3345,0.6104c1.3296-0.0098,3.8267-0.666,5.1587-0.6748c1.3335-0.0088,2.8389-0.6514,4.1743-0.6592
            c1.3335-0.0078,2.4971,0.6191,3.8325,0.6123c2.5518-0.0127,7.3579,0.3965,9.9175,0.3877c5.3169-0.0176,5.5796-0.4063,10.9297-0.4063
            c1.8379,0,6.7031,1.3184,8.3203,1.2402c2.1055-0.1016,3.7139-1.6572,5.5283-1.7969c3.9541-0.3037,7.3262-0.5732,10.5986-0.2598
            c6.248,0.5977,12.1973-0.8125,21.207-0.7539c1.7266,0.0107,15.7813,3.085,17.5,3.0977c3.4014,0.0254,6.6191-1.3398,9.9971-1.3066
            c4.1221,0.041,8.2275,1.2529,12.3369,1.3066c2.0752,0.0273,4.1543-1.1084,6.2314-1.0771c3.3662,0.0498,4.5547,1.0166,7.9346,1.0771
            c2.1104,0.0381,6.4063-0.834,8.5264-0.792c2.7021,0.0537,4.4766-1.6729,7.2002-1.6113c2.9277,0.0654,7.6465,3.1641,10.6074,3.2393
            c4.8359,0.123,8.8809-0.9854,13.832-0.8359c2.5029,0.0752,11.8818,2.0498,14.375,2.1289c1.8398,0.0586,2.499-1.2188,4.334-1.1582
            c2.1689,0.0713,4.5049,1.209,6.666,1.2832c2.6699,0.0908,4.3398-0.916,6.998-0.8203c3.3379,0.1201,6.0566,1.3193,9.377,1.4453
            c4.001,0.1514,4.7764-1.1602,8.75-1c3.1836,0.1289,16.834,1.9912,20,2.125c4.0059,0.1699,4.0029-0.9004,7.9814-0.7227
            c6.8594,0.3076,7.9102,1.7656,14.6855,2.0977c8.916,0.4365,23.5254-0.2432,32.293,0.2344
            c6.7168,0.3662,13.3896,0.7432,20.0186,1.1318C1458.8545,268.4941,1680,316.4209,1680,316.4209H0z" />
          <path id="stone1" d="M680.3335,250.7549c7.3335,0.333,13.6665-1.2549,6-6.4609s-14.333-7.1221-18.6665,0.8359
            S680.3335,250.7549,680.3335,250.7549z" />
          <path id="stone2"
            d="M750.5,243.1709c3.25,0,2.5-3.707-1.75-4.2285s-5,3.7285-3,4.2285S750.5,243.1709,750.5,243.1709z" />
          <path id="stone3" d="M988.4893,243.8242c2.8857,0.3467,4.8438,1.2627,3.0107-2.0703s-7.3955,1.3555-5.2031,1.7129
            S988.4893,243.8242,988.4893,243.8242z" />
          <path id="stone4"
            d="M697,248.9355c2.0142-0.2021,2.1665-2.0156,1-2.1816s-9.1543,1.8398-5.9937,2.6699S697,248.9355,697,248.9355z" />
          <g id="greens" transform="translate(850, 180)">
            <g>
              <path d="M36.3877,59.4268C33.0576,18.9482,6.4658,4.522,6.4658,4.522s22.4834,16.1426,24.4414,54.2251
    C32.8657,96.8311,36.3877,59.4268,36.3877,59.4268z" />
              <path d="M41.8496,83.1641C31.1572,43.98,2.3711,34.6738,2.3711,34.6738s25.063,11.7471,33.9668,48.8271
    C45.2441,120.5791,41.8496,83.1641,41.8496,83.1641z" />
              <path d="M31.3955,60.7207C23.7139,25.7979,2.5381,16.9541,2.5381,16.9541s18.4165,10.9277,24.7925,43.9502
    C33.7061,93.9258,31.3955,60.7207,31.3955,60.7207z" />
              <path d="M40.4517,62.0068C47.9473,21.6187,25.4009,0.1914,25.4009,0.1914s18.0098,21.9634,9.7896,59.6357
    C26.9722,97.499,40.4517,62.0068,40.4517,62.0068z" />
              <path d="M41.9414,69.4316c13.0313-38.9565-6.3218-63.3062-6.3218-63.3062s14.7856,24.251,1.4141,60.4185
    C23.6621,102.709,41.9414,69.4316,41.9414,69.4316z" />
              <path d="M29.4976,87.9092c27.4097-30.5938,19.2993-60.6226,19.2993-60.6226s3.958,28.1255-22.6606,56.0249
    C-0.4775,111.2109,29.4976,87.9092,29.4976,87.9092z" />
              <animateTransform attributeName="transform" type="skewX" values="0;10;0" begin="0s" dur="5.5s"
                fill="freeze" repeatCount="indefinite" />
              <animateMotion type="translate" values="0,0;-10,0;0,0" begin="0s" dur="5.5s" fill="freeze"
                repeatCount="indefinite" />
            </g>
            <g>
              <path d="M34.9995,60.4189C56.0713,30.6665,46.1133,5.4014,46.1133,5.4014S52.2559,29.4746,31.6235,56.79
    C10.9917,84.1035,34.9995,60.4189,34.9995,60.4189z" />
              <path d="M36.3047,64.5391c28.4629-23.4443,25.3262-51.189,25.3262-51.189s-0.293,25.4971-27.6851,46.6538
    C6.5552,81.1631,36.3047,64.5391,36.3047,64.5391z" />
              <path d="M33.0449,70.502c31.4424-19.2637,32.1875-47.1748,32.1875-47.1748s-3.8291,25.208-33.897,42.3584
    C1.271,82.833,33.0449,70.502,33.0449,70.502z" />
              <path d="M13.8237,76.0244c36.5039-5.2158,48.2563-30.543,48.2563-30.543S48.5693,67.1045,14.168,70.9248
    C-20.2324,74.749,13.8237,76.0244,13.8237,76.0244z" />
              <animateTransform attributeName="transform" type="skewX" values="0;15;0" begin="0s" dur="5s" fill="freeze"
                repeatCount="indefinite" />
              <animateMotion type="translate" values="0,0;-15,0;0,0" begin="0s" dur="5s" fill="freeze"
                repeatCount="indefinite" />
            </g>
          </g>
          <g id="sign" transform="translate(700, 180)">
            <polygon points="21.2168,1.1143 20.6665,1.5459 19.7593,1.4473 19.229,1.4209 18.9707,1.6274 18.6665,1.9004 17.6865,1.9219
    37.3516,87.8877 40.8828,87.0791   " />
            <polygon points="45.4111,9.5537 2.4258,18.7158 1.563,18.498 1.4585,17.2114 0.8291,15.583 0.9165,14.3364 0.0908,12.6548
    0.2085,12.0864 -0.1924,11.5308 -0.3296,9.271 43.3408,-0.0376 43.4766,0.5015 43.334,0.9629 43.6533,1.2046 43.8232,1.8784
    43.8965,2.7754 44.2217,3.459 44.625,5.0576 45.041,7.5459 45.2637,7.5962 45.6191,9.0073  " />
            <polygon points="47.0078,20.8545 4.2368,29.5503 3.5933,28.5903 3.3965,26.9746 2.4683,24.5137 2.8398,24.1372 2.2676,23.7847
    1.9834,22.7563 2.2417,22.3394 1.7388,21.8706 1.2627,20.1426 44.8281,11.2852 45.082,12.4014 45.0723,12.9517 45.3281,13.481
    45.752,15.3369 46.0273,17.7524 46.4219,18.2803  " />
            <polygon points="47.666,31.168 4.7803,39.4023 4.251,37.4004 4.4429,36.1895 3.6465,35.1123 3.0142,32.7178 3.2754,32.1025
    2.7461,31.7046 2.2676,29.8945 45.9268,21.5107 46.0762,22.2007 45.9512,22.8423 46.2783,23.1372 46.6777,24.9795 46.5234,25.4795
    47.3027,27.8667 47.8086,30.2017   " />
          </g>
          <g id="boy_1_">
            <g id="boy">
              <path d="M800.7324,167.6929c0,0-7.9688-6.5039-9.7197-8.041c-1.751-1.5366-7.9331-6.5039-8.7197-13.0435
    c-0.7861-6.5396,6.0752-15.188,17.7969-16.1885c11.7207-1.0005,12.9727,1.0366,14.1514,2.7163
    c1.1787,1.6792,5.7178,11.1494,5.0752,18.6538c-0.6445,7.5049-5.6826,10.1133-9.7559,13.3652
    C805.4863,168.4072,800.7324,167.6929,800.7324,167.6929z" />
              <path
                d="M810.7031,169.2109c-1.0723-1.3037-1.3574-2.9556-1.1426-4.0645c0.2139-1.1084-8.041,0.1128-8.8281,2.542
    c1.6445,1.6787,0.751,3.146-0.5,4.1108c-1.25,0.9648-1.6797,1.502-1.9297,1.8237c0.0361,0.5361,0,0.9653,0,0.9653
    s-1.4297,1.7153-2.2871,6.5396s-0.6787,6.79-0.9648,8.3267c-0.2852,1.5366-1.4648,5.9678-1.751,10.292s0,4.5742,0,4.5742
    s1.251,1.7153,1.1436,4.0742s-1.2705,5.6099-1.2705,5.6099s0.2344,1.8945,1.8779,2.252c1.6445,0.3574,2.3594-0.6436,2.3594-0.6436
    s1.0713,1.3223,1.75,4.0742c0.6797,2.752,0.6436,6.79,1.8945,7.9688c1.251,1.1797,1.6074,0.3223,1.6074,0.3223
    s0.4648,3.3975-0.9277,6.6855c-1.3945,3.2881-4.1465,6.7568-4.1465,6.7568h11.0781c0,0,1.5723-3.5234-7.1113-2.2363
    c3.252-4.0742,3.8955-6.1934,4.0391-11.125c1.8223,0.5,4.252,0.6738,4.9316-0.3271c0.5352,1.3223,2.4297,2.1787,3.3584,1.7139
    c-0.2139,3.7168-1.0713,12.1846-1.0713,12.1846l9.0049,0.2852c0,0-0.751-3.2168-6.29-1.4307
    c1.001-6.7891,1.3584-11.5068,1.3584-11.5068s1.3584,0.1074,1.8584-0.3926c0.5-0.501,0.6787-5.3252-0.4648-9.9346
    c-1.1436-4.6104-0.5-4.4678-0.5-4.4678s1.75-0.8213,1.5-2.8584s-0.8574-3.6807-1.5352-5.5391
    c0.4639-0.1074,1-0.7861-0.6797-2.7158c-0.2148-2.5015-0.9648-6.3242-0.6436-7.6465s0.2148-2.8232-0.1787-4.3599
    c0-2.4302,0.7148-13.1509-1.25-17.0103c-1.9658-3.8594-2.5371-3.5737-2.5371-3.5737S812.5977,169.0142,810.7031,169.2109z" />
            </g>
            <g transform="translate(783, 122)">
              <g>
                <path d="M35.3506,17.9644c2.9834-3.71,5.9824-15.2095-3.1846-18.3765c2.668,3.833,1.168,5.6665,1.168,5.6665
    S32,1.2549,28.666-0.4121c1.5,3.1665,0,5,0,5S20.5,8.9209,24.5,13.2544S35.3506,17.9644,35.3506,17.9644z" />
                <animateTransform attributeName="transform" type="skewX" values="0;30;0" begin="0s" dur="4s"
                  fill="freeze" repeatCount="indefinite" />
                <animateMotion type="translate" values="0,0;-10,0;0,0" begin="0s" dur="4s" fill="freeze"
                  repeatCount="indefinite" />
              </g>
              <g>
                <path d="M27.125,6.2334c-1.8125-0.625-2.0625-1.9375-4.375-2.25c1,0.8125,1.125,1.6875,1.125,1.6875S21.5,4.3584,19.0625,3.9834
    c1.3125,0.75,2,1.875,2,1.875s-3.25-0.75-5.875-0.75c1.125,0.3125,1.125,0.6875,1.125,0.6875S10.75,5.8584,8.6875,7.4834
    c1,0.125,0.9375,0.6714,0.9375,0.6714s-4.25,1.5786-5.375,3.7661c0.875-0.4375-0.8125,1.8125-0.8125,1.8125s0.75,1.375-0.3125,1.125
    S0.5,14.1084,0.5,12.5459c-0.5,2.1875,0.6924,2.5767,1.4375,3.3125c-0.0625,1-0.9375,2.6494-1.25,2.106s0.8594,0.4282,0.0547,2.4731
    c-0.8047,2.0459-1.1533,3.7432-0.5103,6.5195s2.7056,4.5264,3.5181,6.2139s0.5-1.6875,0.5-1.6875L27.125,6.2334z" />
              </g>
            </g>
          </g>
        </svg>
      </div>
    </div>
  </div>
  <script src="https://unpkg.com/three@0.152.2/examples/js/loaders/FontLoader.js"></script>
<script src="https://unpkg.com/three@0.152.2/examples/js/geometries/TextGeometry.js"></script>
<script src="https://unpkg.com/three@0.152.2/examples/js/exporters/OBJExporter.js"></script>
</body>

</html>